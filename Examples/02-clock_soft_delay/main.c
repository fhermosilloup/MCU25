/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
/* Private includes -----------------------------------------------*/
#include "stm32f103xb.h"

/* Private defines ------------------------------------------------*/
#define SystemCoreClock		(8000000UL)

/* Private macros -------------------------------------------------*/
#define BIT(n)				(1UL << (n))

/* Private typedefs ------------------------------------------------*/

/* Private variables -----------------------------------------------*/

/* Private prototype function --------------------------------------*/
void SysReset_Check(void);
void SystemClock_Config(void);
void MX_GPIO_Init(void);
void delay_ms(uint32_t ms);

/* Main program ----------------------------------------------------*/
/*
 * Activities:
 * 1. Verify the code provided by professor, specifically the 
 * 	  software delay function "delay_ms".
 * 2. Configure the system clock to 72MHz (AHB), the APB1 to its
 *    max value, the clock of APB2 to AHB clk, while use the HSE
 *    clock to feed the PLL
 * 3. Modify the software delay function "delay_ms" taking into
 *    account the new system clock.
 */
int main(void)
{
	/* Check system reset */
	SysReset_Check();

	/* System Clock configuration */
	SystemClock_Config();

	/* GPIO initialization */
	MX_GPIO_Init();

	/* Loop forever */
	while (1)
	{
		// PA5 toggle
		GPIOA->ODR ^= BIT(5);
		
		// Software delay
		delay_ms(1);
	}
}


/* Private function definition -------------------------------------*/
void delay_ms(uint32_t ms)
{
	// Declared as volatile to avoid compiler optimization
	volatile uint32_t cycles = 0;
	while(ms--)
	{
		/*
		 * This for loop takes 10 cycles per iteration
		 * The outer while takes 4 cycles per iteration
		 * Ideally, for a delay of 1ms we need a for loop
		 * from 0 to Fclk / 1000 clock cycles if we assume
		 * that each iteration takes 1 clock cycle.
		 *
		 * If Fclk = 8MHz -> 8MHz/1000 = 8000
		 *
		 * However, at low-level, each iteration of the for
		 * loop takes around 10 clock cycles, therefore
		 * instead of iterating up to Fclk / 1000, it
		 * should be Fclk / (1000*CYCLES_PER_ITER), i.e.,
		 * 8MHz/(1000*10) = 800
		 */
		for (cycles = 0; cycles < 800; cycles++)
		{
		}
	}

}


void SysReset_Check(void)
{
	if( RCC->CSR & BIT(31) )
	{
		// Handle low-power reset
	}
	else if( RCC->CSR & BIT(30) )
	{
		// Handle WWDG reset
	}
	else if( RCC->CSR & BIT(29) )
	{
		// Handle IWDG reset
	}
	else if( RCC->CSR & BIT(28) )
	{
		// Handle Software reset
	}
	else if( RCC->CSR & BIT(27) )
	{
		// Handle POR/PDR reset
	}
	else if( RCC->CSR & BIT(26) )
	{
		// Handle NRST pin reset
	}

	// Clear reset flags
	RCC->CSR |= BIT(24);
}

void SystemClock_Config(void)
{
	/*
	 * 								----- [/2] ----[APB1]
	 * 							   /
	 * [SYSCLK] - [/1] - [AHBCLK] -
	 * 							   \
	 * 							    ----- [/1] ----[APB2]
	 * Summary:
	 * SYSCLK = 72MHz @HSI x PLLMUL
	 * AHBCLK = 72MHz
	 * APB1CLK = 36MHz
	 * APB2CLK = 72MHz
	 */
	/* 1. Enable HSE clock */
	RCC->CR |= BIT(16);				// Enable HSE signal
	while( !(RCC->CR & BIT(17)) ); 	// Polling for HSE Ready

	/* 2. Enable pre-fetch buffer */
	FLASH->ACR |= BIT(4);			// Enable pre-fetch
	while( !(FLASH->ACR & BIT(5)) );// Polling for pre-fetch buffer enable

	/* 3. Set wait states */

	/*
	 * 4. Configure prescaler, multiplier and clock MUX.
	 *
	 * Goal: SYSCLK = 72MHz from PLLCLK driven from the HSE clock
	 * APB2CLK = SYSCLK, APB1CLK = 36MHz
	 */
	// Prescalers (APB1, APB2, AHB, ADC, USB)
	
	// MUX (HSE_PRESCALER, PLL_HSE_INPUT, PLLMULL)

	/* 5. Enable PLL*/

	/* 6. Set clock source */
}

void MX_GPIO_Init(void)
{
	// Enable clock for GPIOA & GPIOD peripherals
	RCC->APB2ENR |= BIT(2) | BIT(5);

	// PA5 as push-pull output (2 MHz)
	GPIOA->CRL &= ~(0x0F << 20); // Clear MODE5 & CNF5
	GPIOA->CRL |= BIT(21);
}
