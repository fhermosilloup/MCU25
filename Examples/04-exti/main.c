/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
/* Private includes -----------------------------------------------*/
#include "stm32f103xb.h"

/* Private defines ------------------------------------------------*/

/* Private macros -------------------------------------------------*/
#define BIT(n)				(1UL << (n))

#define __enable_irq() 		__asm volatile ("cpsie i" : : : "memory")
#define __disable_irq() 	__asm volatile ("cpsid i" : : : "memory")

/* Private typedefs ------------------------------------------------*/

/* Private variables -----------------------------------------------*/

/* Private prototype function --------------------------------------*/
void SysReset_Check(void);
void SystemClock_Config(void);
void MX_GPIO_Init(void);
void MX_EXTI_Init(void)

void delay_ms(uint32_t ms);


/* Main program ----------------------------------------------------*/
int main(void)
{
	/* Check system reset */
	SysReset_Check();

	/* System Clock configuration */
	SystemClock_Config();

	/* GPIO initialization */
	MX_GPIO_Init();
	
	/* EXTI initialization */
	
	/* Application loop forever */
	while (1)
	{
		
	}
}


/* Private function definition -------------------------------------*/
void SysReset_Check(void)
{
	if( RCC->CSR & BIT(31) )
	{
		// Handle low-power reset
	}
	else if( RCC->CSR & BIT(30) )
	{
		// Handle WWDG reset
	}
	else if( RCC->CSR & BIT(29) )
	{
		// Handle IWDG reset
	}
	else if( RCC->CSR & BIT(28) )
	{
		// Handle Software reset
	}
	else if( RCC->CSR & BIT(27) )
	{
		// Handle POR/PDR reset
	}
	else if( RCC->CSR & BIT(26) )
	{
		// Handle NRST pin reset
	}

	// Clear reset flags
	RCC->CSR |= BIT(24);
}

void SystemClock_Config(void)
{
	/* 1. Enable HSE clock and polling */

	/* 2. Enable pre-fetch buffer and polling [FLASH_ACR] */

	/* 3. Set wait states and polling [FLASH_ACR] */

	/* 4. Configure prescaler, multiplier and clock MUX. */
	// Prescalers: APB1, APB2, AHB, USB, ADC [RCC_CFGR]
	
	// MUX [RCC_CFGR]

	/* 5. Enable PLL and polling */

	/* 6. Set clock source and polling */
}

void MX_GPIO_Init(void)
{
	// Enable clock for GPIOA, GPIOD peripherals
	RCC->APB2ENR |= BIT(2) | BIT(5);

	// PA5 as push-pull output (2 MHz)
	GPIOA->CRL &= ~(0x0F << 20); // Clear MODE5 & CNF5
	GPIOA->CRL |= BIT(21);
}

void MX_EXTI_Init(void)
{
	// Enable EXTI clock by enabling the AFIO clock (APB2)

	// Connect EXTI0 line to PA0/PB0 on the AFIO's EXTICRs registers

	// Disable the 'rising edge' trigger on EXTI RTSR register
	
	// Enable/disable the 'falling edge' trigger on EXTI FTSR register

	// Setup EXTI1 line as an interrupt on EXTI IMR register

	/* Set priority: The priority field holds an 8-bit priority value.
	 * The lower the value, the greater the priority of the
	 * corresponding interrupt. The processor implements only bits[7:4]
	 * of each field, bits[3:0] read as zero and ignore writes.
	 *
	 * Although the NVIC_IPx are 32-bit registers (x = 0,...,16)
	 * the library define these registers as an array of 8-bit
	 * registers, where the location of the interrupt source is the
	 * index on the array. In this case the location of EXTI1 in the
	 * interrupt vector table is 7.
	*/

	/* Enable EXTI1 interrupt: NVIC ISER1-ISER3 are read-set register, i.e.,
	 * writing zero does not take effect on the register value.
	 * Location	Set-enable	Clear-enable	Set-pending	Clear-pending	Active Bit
	 * 0-31 	ISER[0] 	ICER[0] I		SPR[0] 		ICPR[0] 		IABR[0]
	 * 32-63 	ISER[1] 	ICER[1] 		ISPR[1] 	ICPR[1] 		IABR[1]
	 * 64-80 	ISER[2] 	ICER[2] 		ISPR[2] 	ICPR[2] 		IABR[2]
	 *
	 * Since EXTI1 is located at position 7, to enable its interrupt
	 * we need to set bit 7 of ISER[0].
	 */

}


void delay_ms(uint32_t ms)
{
	// Declared as volatile to avoid compiler optimization
	volatile uint32_t cycles = 0;
	while(ms--)
	{
		/*
		 * This for loop takes 10 cycles per iteration
		 * The outer while takes 4 cycles per iteration
		 * Ideally, for a delay of 1ms we need a for loop
		 * from 0 to Fclk / 1000 clock cycles if we assume
		 * that each iteration takes 1 clock cycle.
		 *
		 * If Fclk = 8MHz -> 8MHz/1000 = 8000
		 *
		 * However, at low-level, each iteration of the for
		 * loop takes around 10 clock cycles, therefore
		 * instead of iterating up to Fclk / 1000, it
		 * should be Fclk / (1000*CYCLES_PER_ITER), i.e.,
		 * 8MHz/(1000*10) = 800
		 */
		for (cycles = 0; cycles < 800; cycles++)
		{
		}
	}

}




/* Interrupt Handlers ------------------------------------------------*/
void EXTI1_IRQHandler(void)
{
	// Check EXTI1 pending flag
	if (EXTI->PR & BIT(1))
	{
		// Clear the EXTI interrupt status
		EXTI->PR = BIT(1);

		// USER CODE HERE ....
		
	}
}
